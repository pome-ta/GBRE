# GBRE アーキテクチャ詳細解説

このドキュメントは、GBRE エミュレータのコアである `app.js` の内部構造と主要なコードブロックの役割について、前提知識がない方でも理解できるよう、詳細に解説します。

## はじめに：ゲームボーイはどのように動くか？

このエミュレータが何をしているかを理解するために、まず実機のゲームボーイがどのようにゲームを動かしているか、簡単なモデルで見てみましょう。

ゲームボーイの中には、主に 4 つの重要な役割を持つ部品があります。

1.  **CPU（中央処理装置）**: ゲームの頭脳です。「右に 1 歩進む」「ジャンプする」といったゲームのプログラム（命令）を一つずつ読み解き、他の部品に指示を出します。
2.  **メモリ (RAM/ROM)**: 作業机のようなものです。CPU が計算する途中の値を置いたり、プログラムそのものが置かれています。ROM にはゲームソフトのデータが、RAM にはセーブデータや一時的なデータが保存されます。
3.  **PPU（描画処理装置）**: 映像担当です。CPU から「このキャラクターをこの場所に表示して」という指示を受け、それを元に画面に表示する 1 枚の絵を描画します。
4.  **APU（音声処理装置）**: 音響担当です。CPU から「この効果音を鳴らして」という指示を受け、スピーカーから音を出します。

エミュレータとは、これらハードウェアの「動き」をすべてソフトウェアで真似（エミュレート）するプログラムです。`app.js` の中では、これらの役割が以下のようにコードで表現されています。

- **CPU の動き** → メインループ `o.ff[1000]` と、各命令に対応する関数群 `o.ff[0]` ~ `o.ff[0x1ff]`
- **メモリ** → 巨大な配列 `o.m`
- **CPU の作業場所(レジスタ)** → 配列 `o.r`
- **PPU の動き** → 描画関連の関数群 `o.ff[1101]` ~
- **APU の動き** → 音声関連の関数群 `o.ff[1200]` ~

この対応関係を頭に入れておくと、以下の解説が理解しやすくなります。

---

## `app.js` コードブロック詳細解説

`docs/js/app.js` は、大きく分けて以下のブロックで構成されています。

### 1. グローバルオブジェクト `o` の初期化

エミュレータの全体的な状態を管理する「親」となるオブジェクト `o` を定義し、その中にエミュレータの各部品に相当するプロパティを初期化します。

- **`o.ff` (Function Factory)**: 関数テーブル。CPU の命令（「A と B を足す」など）や、ボタンが押された時の処理など、エミュレータのあらゆる「動作」がこの巨大な配列に格納されています。CPU は次に実行すべき命令コードを読み取り、このテーブルから対応する関数を呼び出して実行します。
- **`o.m` (Memory)**: ゲームボーイの全メモリ空間（64KB）を確保する `Uint8Array` です。ゲームのプログラム(ROM)、一時的な作業領域(WRAM)、画面の部品データ(VRAM)、セーブデータ(Cartridge RAM)などがすべてこの配列上にマッピングされます。
- **`o.r` (Registers)**: CPU 内部にある高速な記憶領域「レジスタ」を保持する `Int32Array` です。計算途中の数値を一時的に置いたり、次に実行する命令のアドレス(PC: プログラムカウンタ)を覚えておくために使われます。
- **`o.h`, `o.hh`, `o.b`**: デバッグ表示用のヘルパー関数です。数値を 16 進数や 2 進数の文字列に変換するのに使われます。

### 2. デバッグ用ヘルパー関数

開発者がエミュレータの内部状態を確認するための補助関数です。

- **`o.ffrr`**: 現在のレジスタ(`o.r`)や I/O レジスタ(`o.m`の`0xFF00`番台)の値を整形して、人間が読める文字列として返します。
- **`o.ffmm`**: 指定されたメモリアドレス範囲の内容を 16 進数ダンプ形式で表示します。
- **`o.fftt`**: 文字列を画面上のテキストエリアに表示します。

### 3. デバッグ表示制御関数

デバッグ情報を効率的に画面に表示するための仕組みです。

- **`o.ff[811]`**: 表示したいデバッグ情報を、一旦内部のバッファ用配列にセットします。
- **`o.ff[812]`**: メインループの最後に呼ばれ、バッファに溜まった情報をまとめてテキストエリアに書き出します。これにより、ループの度に画面を更新する負荷を避けています。

### 4. エミュレータ起動・UI イベントハンドラ

ユーザーの操作（クリックやボタン押し）を起点として、エミュレータの動作を開始・制御する部分です。

- **`o.ff[999]`**: **エミュレータ起動トリガー**。画面がクリックされると最初に呼ばれます。PPU(`o.ff[1101]`)と APU(`o.ff[1200]`)を初期化し、エミュレータの心臓部であるメインループ(`o.ff[1000]`)を起動します。
- **`o.ff[1999]`**: UI ボタンの共通イベントハンドラ。どのボタンが押されたかを判断し、`o.ff[2000]`以降の対応する処理を呼び出します。
- **`o.ff[2000]`〜`o.ff[2018]`**: 「リセット」「セーブ」「ロード」「FPS 変更」など、各 UI ボタンに対応する個別の処理です。

### 5. 関数テーブルの初期化

`o.ff`（関数テーブル）のうち、CPU 命令や I/O ハンドラが格納される範囲を、何もしない空の関数で初期化します。これは、未実装の命令が呼び出された場合にエミュレータがエラーで停止（クラッシュ）するのを防ぐための安全装置です。

### 6. メモリバス (Read/Write)

CPU がメモリを読み書きする際の「窓口」となる非常に重要な関数です。

- **`o.ff[800]` (Read Bus)**: CPU が特定のアドレスからデータを読み込もうとすると、この関数が呼ばれます。アドレスに応じて、それが ROM 領域なのか、VRAM 領域なのか、あるいは特殊なハードウェアレジスタなのかを判断し、適切な場所からデータを返します。
- **`o.ff[801]` (Write Bus)**: CPU が特定のアドレスにデータを書き込もうとすると、この関数が呼ばれます。Read 同様に書き込み先を判断しますが、特に重要なのは、特定の I/O レジスタ（例: `0xFF46` DMA 転送）に書き込みがあった際に、それに対応するハードウェアの動作（DMA 転送の開始など）をトリガーする役割を担っている点です。

### 7. セーブ/ロード処理

ゲームの進行状況を保存・復元する機能です。

- **`o.ff[820]`**: RAM の内容を画像データに変換し、それを Base64 形式の文字列としてブラウザの`localStorage`に保存します。RAM を画像として保存するのは、データをコンパクトに扱うためのテクニックです。
- **`o.ff[821]`, `o.ff[822]`**: 保存された Base64 文字列から画像を復元し、そのピクセルデータを RAM に書き戻すことで、ゲームの状態を復元します。

### 8. I/O レジスタハンドラ (`o.ff[0x200]`台)

`0xFF00`番台の特殊なメモリアドレス（I/O ポート）に書き込みがあった際に、メモリバス(`o.ff[801]`)から呼び出される関数群です。これにより、ゲームソフトはハードウェアを直接制御します。

- **`o.ff[0x00 | (1 << 9)]` (FF00 - P1/JOYP)**: ジョイパッドの制御。どのボタン（方向キーか、A/B ボタンか）の状態を読み取るかを切り替えます。
- **`o.ff[0x46 | (1 << 9)]` (FF46 - DMA)**: DMA（Direct Memory Access）転送を開始します。指定されたメモリ領域のデータを、CPU を介さずに高速に VRAM へ転送するための機能で、主に画面描画の準備に使われます。
- **`o.ff[0x10-0x3F | (1 << 9)]`**: APU（サウンド）関連のレジスタ。音の高さ、大きさ、長さ、音色などを設定します。
- **`o.ff[0x50 | (1 << 9)]` (FF50 - Boot ROM Disable)**: ゲームボーイ起動時に最初に実行される内蔵ブート ROM を無効化し、ゲームカートリッジのプログラムに制御を渡します。

### 9. PPU (描画) 関連 (`o.ff[1101]` ~)

ゲーム画面を描画するための機能群です。

- **`o.ff[1101]`**: PPU 関連のオブジェクト(`o.v`)や、画面描画に使う`canvas`を初期化します。
- **`o.ff[1102]`**: **スキャンライン描画**。ゲーム画面の上から 1 行分のピクセルを描画する、PPU の最重要処理です。背景、ウィンドウ、スプライト（キャラクターなど）を正しい優先順位で重ね合わせて 1 ラインの絵を作ります。
- **`o.ff[1103]`**: VRAM 上のタイルデータ（8x8 ピクセルの絵の部品）を、高速に描画できる形式にデコードしてキャッシュ（一時保存）します。
- **`o.ff[1104]`**: 1 フレーム（144 ライン）分の描画が完了した内部イメージを、実際に画面の`<canvas>`に転送（表示）します。

### 10. APU (音声) 関連 (`o.ff[1200]` ~)

ゲームの BGM や効果音を再生するための機能群です。

- **`o.ff[1200]`**: ブラウザの Web Audio API を使って、音声再生の準備をします。矩形波やノイズを生成するための「発振器（Oscillator）」などを用意します。
- **`o.ff[1201]`**: CPU からの指示に基づき、各サウンドチャンネルの周波数（音の高さ）を設定します。
- **`o.ff[1202]`**: チャンネル 1 のスイープ機能（ピヨピヨといった音程が変化する効果）を処理します。

### 11. CPU 命令セット (`o.ff[0x00]` ~ `o.ff[0x1FF]`)

CPU が実行する個々の命令に対応する関数群です。詳細は後述します。

### 12. CPU 命令: 演算命令群

A レジスタ（アキュムレータ）を中心に、数値の計算や論理演算を行います。

- **ADD (加算)**: `o.ff[0x80]` ~ : A レジスタに値を足します。
- **SUB (減算)**: `o.ff[0x90]` ~ : A レジスタから値を引きます。
- **AND, OR, XOR (論理演算)**: `o.ff[0xa0]` ~ : ビットごとの論理演算を行います。
- **CP (比較)**: `o.ff[0xb8]` ~ : A レジスタと値を比較し、結果をフラグに反映させます（A レジスタの値は変わりません）。
- **INC/DEC (増減)**: `o.ff[0x04]` ~ : レジスタの値を 1 増やしたり減らしたりします。

### 13. CPU 命令: 回転・シフト命令群

レジスタの値をビット単位でずらす（回転・シフト）命令です。

- **RLCA, RLA**: `o.ff[0x07]`, `o.ff[0x17]`: 左に回転させます。
- **RRCA, RRA**: `o.ff[0x0f]`, `o.ff[0x1f]`: 右に回転させます。
- **SLA, SRA, SRL**: `o.ff[0x120]` ~ : 左または右にシフトします。

### 14. CPU 命令: ビット操作命令群

レジスタの特定の 1 ビットを操作する命令です。

- **BIT**: `o.ff[0x140]` ~ : 指定したビットが 0 か 1 かをテストします。
- **RES**: `o.ff[0x180]` ~ : 指定したビットを 0 にします（リセット）。
- **SET**: `o.ff[0x1c0]` ~ : 指定したビットを 1 にします（セット）。

### 15. CPU 命令: ジャンプ・コール命令群

プログラムの実行順序を制御します。

- **JP (ジャンプ)**: `o.ff[0xc3]` ~ : 指定したアドレスに無条件に移動します。
- **JR (相対ジャンプ)**: `o.ff[0x18]` ~ : 現在位置から見て、指定した数だけ前後に移動します。
- **CALL (サブルーチンコール)**: `o.ff[0xcd]` ~ : 別の処理（サブルーチン）を呼び出します。終わったら元の場所に戻ってきます。
- **RET (リターン)**: `o.ff[0xc9]` ~ : サブルーチンから元の場所に戻ります。

### 16. CPU 命令: スタック操作命令群

CALL 命令などで戻るべき場所を覚えておくために、「スタック」と呼ばれるメモリ領域を使います。

- **PUSH**: `o.ff[0xc5]` ~ : レジスタの値をスタックに積みます。
- **POP**: `o.ff[0xc1]` ~ : スタックから値を取り出してレジスタに戻します。

### 17. メインループ (`o.ff[1000]`) の詳細

エミュレータ全体の動作を司る心臓部です。`setTimeout` によって 1 秒間に約 60 回呼び出され、1 回の呼び出しで 1 フレーム分の処理を実行します。

1.  **タイミング調整**: 前回の実行からの時間差をみて、エミュレーション速度が実機と同じ約 60FPS になるように待ち時間を調整します。
2.  **CPU サイクル実行ループ**: 1 フレーム分の CPU クロック数に達するまで、以下の 3〜5 を高速で繰り返します。
3.  **割り込みチェック**: VBlank（描画完了）やタイマーなどの割り込み要求があるか確認します。あれば、現在の作業を中断して割り込み処理にジャンプします。
4.  **命令のフェッチと実行**: 割り込みがなければ、プログラムカウンタ(PC)が指すメモリアドレスから命令を 1 つ読み込み（フェッチ）、`o.ff`テーブルから対応する関数を実行します。
5.  **各種ハードウェアの更新**: 命令の実行にかかった時間（サイクル数）ぶん、タイマー、PPU、APU の状態を更新します。特に PPU は、サイクルが進むごとにスキャンラインの位置が変化し、HBlank や VBlank といった描画ステータスが切り替わっていきます。
6.  **次のフレームへ**: 1 フレーム分のサイクルをすべて消費したらループを抜け、次の`setTimeout`による呼び出しを待ちます。
