# プロジェクト概要

このファイルは、プロジェクトの全体像と現在の状態を把握するためのドキュメントです。
エージェント（AI アシスタント）や新しいプロジェクトメンバーが、最初にこのファイルを読み込むことを想定しています。

## 0. AIアシスタント (Gemini) への指示

**重要:**
このプロジェクトのコードベース、特に `docs/js/app.js` は非常に大きいため、一度に広範囲の変更を提案するとメモリ不足でエラーが発生する可能性があります。

リファクタリングやコード生成を行う際は、**必ず処理の粒度を小さくし、一度に変更する範囲を限定してください。**

一つの関数、一つの命令グループなど、細かな単位で作業を進めることを強く推奨します。

## 1. プロジェクトの目的

このプロジェクトは、単一の HTML ファイル `GBRE.html` に実装されているゲームボーイエミュレータのコードをリファクタリングし、保守性と可読性を向上させることを目的とします。

主なゴールは以下の通りです。

- HTML, CSS, JavaScript をそれぞれ適切なファイルに分割する。
- 難読化されている JavaScript コードを解析し、人間が読んで理解できるコードに修正する。

## 2. アーキテクチャ

### 現状の構成

- `GBRE.html`: すべての HTML, CSS, JavaScript コードが含まれている。

### 目指す構成

- `docs/index.html`: アプリケーションのエントリーポイント。
- `docs/css/style.css`: スタイルシート。
- `docs/js/app.js`: アプリケーションロジック。

## 3. 主要なコンポーネント

プロジェクトを構成する主要なフォルダやファイルの役割を説明します。

- `GBRE.html`: リファクタリング対象のオリジナルファイル。
- `docs/`: リファクタリング後のファイルを格納するディレクトリ。
- `agentNotes/`: リファクタリング作業に関するメモやドキュメントを格納するディレクトリ。
  - `project_overview.md` (このファイル): プロジェクトの全体像、目的、方針を記述します。 **新しい担当者はまずこのファイルを読んでください。**
  - `implementation_plan.md`: 今後の実装計画やタスク（バックログ）を管理します。作業に着手する際は、ここからタスクを取得し、ステータスを更新します。
  - `development_log.md`: 日々の開発作業や調査内容、方針決定などを時系列で記録します。 **作業内容は必ずここに追記してください（最新のものが一番上になるように）。**
  - `refactoring_log.md`: 具体的なコードの変更内容を、ファイルごと、機能ごとに記録します。
  - `coding_rules.md`: プロジェクト内でのコーディング規約を定めます。

## 4. セットアップと実行方法

`docs/index.html` を Web ブラウザで開くことでアプリケーションを実行します。

### 実行環境

- デスクトップ: Chrome, Safari
- モバイル: iPhone (Mobile Safari)

## 5. 現在の状況と次のステップ

### 現在の状況

- `GBRE.html` から `docs/index.html`, `docs/css/style.css`, `docs/js/app.js` へのコードの初期分割が完了しています。

### 開発方針と次のステップ

リファクタリングの安全性を高めるために TDD（テスト駆動開発）の導入を検討し、テスト環境の構築を試みましたが、現状のコードが密結合であるため、テストの導入がリファクタリング作業そのものを複雑化させてしまう可能性が懸念されました。

そこで、一旦 TDD の導入は見送り、まずはコードの可読性を直接向上させることに集中する方針としました。

具体的な次のステップは以下の通りです。

- `docs/js/app.js` のコードを解析し、役割が判明した変数名・関数名を、意味のわかる名前に変更する（リネーム）。
- 処理のまとまりごとにコメントを追記し、コードの意図を明確にする。

## 6. コード解析メモ

### 6.1 グローバルオブジェクト `o`

- **`o`**: エミュレータ全体の状態と機能を保持するグローバルオブジェクト。
  - **`o.m` (Memory)**: ゲームボーイのメモリ全体 (ROM, VRAM, WRAM 等) を格納する `Uint8Array`。
  - **`o.r` (Registers)**: CPU レジスタ (PC, SP, A, F, B, C, D, E, H, L 等) の値を保持する `Int32Array`。
  - **`o.ff` (Functions)**: CPU 命令やイベント処理に対応する関数の巨大な配列。 **このエミュレータの挙動を定義する中心的な要素。** (詳細は 6.2 を参照)
  - **`o.v` (Video)**: 画面描画関連のオブジェクト (`canvas`コンテキスト等)。
  - **`o.s` (Sound)**: Web Audio API を利用した音声関連のオブジェクト。
  - **`o.h`, `o.hh`, `o.b`**: 数値を 16 進数や 2 進数の文字列に変換するためのヘルパー。
  - **`o.ffrr`, `o.ffmm`**: デバッグ用にメモリやレジスタの状態を文字列化する関数。

### 6.2 関数テーブル `o.ff` 構造マップ

`o.ff` は、オペコードや特定の ID をインデックスとして、対応する処理を呼び出すための巨大な関数配列です。以下にその構造をまとめます。

| インデックス範囲  | カテゴリ                       | 説明                                                                                                                         |
| ----------------- | ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------- | ---------------------- |
| `0x00` - `0xFF`   | **CPU 基本命令**               | `NOP`, `LD`, `ADD`, `JP` など、基本的な CPU 命令セット。`0xCB` は拡張命令へのプレフィックス。                                |
| `0x100` - `0x1FF` | **CPU 拡張命令 (CB-prefixed)** | `RLC`, `BIT`, `SET`, `RES` など、`0xCB` に続けて実行される命令セット。`n                                                     | (1 << 8)` でアクセス。 |
| `0x200` - `0x2FF` | **I/O レジスタハンドラ**       | `0xFFxx` の I/O レジスタへの書き込み時に実行される特殊な処理。`p                                                             | (1 << 9)` でアクセス。 |
| `800` - `847`     | **コアロジック・ヘルパー**     | メモリバス(`800`, `801`)、セーブ/ロード(`820-822`)、ROM 解析(`831-834`)、ファイル読み込み(`844-846`)など。                   |
| `996` - `999`     | **イベントハンドラ**           | `onload`, キーボード/タッチ入力(`997`, `998`)、エミュレータ起動トリガー(`999`)など。                                         |
| `1000`            | **メインループ**               | CPU 命令実行、割り込み、タイマー、PPU/APU 更新を行うエミュレータの心臓部。`setTimeout`で再帰的に呼ばれる。                   |
| `1101` - `1177`   | **PPU / VRAM / MBC 関連**      | 描画初期化(`1101`)、スキャンライン描画(`1102`)、タイルデータデコード(`1103`)、VRAM DMA(`1106`)、MBC7 処理(`1175-1177`)など。 |
| `1200` - `1202`   | **APU (音声) 関連**            | Web Audio API の初期化(`1200`)、周波数設定(`1201`)、スイープ処理(`1202`)など。                                               |
| `1977` - `1987`   | **デバッグ表示バッファ**       | デバッグ情報をテキストエリアに表示するための一時的なデータ保持領域として使用。                                               |
| `2000` - `2018`   | **UI ボタンハンドラ**          | `Reset`(`2000`)、`Open URL`(`2001`)、`Save`(`2002`)など、画面上のボタンに対応する処理。                                      |

### 6.3 主要な処理の流れ

1.  `onload` イベントで各種 DOM 要素の生成、イベントハンドラの設定、ブートストラップ ROM(`o.ff[832]`)の読み込みが行われる。
2.  画面がクリックされると `o.ff[999]` が発火し、描画(`o.ff[1101]`)と音声(`o.ff[1200]`)の初期化が行われた後、メインループである `o.ff[1000]` が開始される。
3.  メインループ(`o.ff[1000]`)は、1 フレーム分の CPU サイクル数に達するまで、CPU 命令のフェッチ・実行、割り込み処理、各種ハードウェア（タイマー、PPU、APU）の状態更新を繰り返す。
4.  PPU は、HBlank, VBlank などのタイミングでスキャンライン描画(`o.ff[1102]`)や画面更新(`o.ff[1104]`)を行う。
5.  ユーザーの入力は、キーボード(`o.ff[997]`)やタッチ(`o.ff[998]`)イベントとして検知され、ジョイパッドレジスタの状態を更新する。

### 6.4 `app.js` コードブロック詳細

`docs/js/app.js` は、大きく分けて以下のブロックで構成されています。

#### 1. グローバルオブジェクト `o` の初期化

エミュレータの全体的な状態を管理するグローバルオブジェクト `o` を定義し、主要なプロパティを初期化します。

- **`o.ff`**: 関数テーブル。CPU 命令やイベントハンドラなど、エミュレータの様々な処理を格納する巨大な配列です。
- **`o.m`**: メモリ。ゲームボーイの全メモリ空間（ROM, RAM, VRAM など）を確保する `Uint8Array` です。
- **`o.r`**: レジスタ。CPU のレジスタ群（PC, SP, A, F, B, C, D, E, H, L など）を保持する `Int32Array` です。
- **`o.h`, `o.hh`, `o.b`**: デバッグ表示用のヘルパー。数値を 16 進数や 2 進数の文字列に変換するためのテーブルと関数です。

#### 2. デバッグ用ヘルパー関数

デバッグ情報を画面に表示するためのヘルパー関数群です。

- **`o.ffrr`**: レジスタと I/O の状態を整形して文字列として返します。デバッグ表示で使用されます。
- **`o.ffmm`**: 指定されたアドレス範囲のメモリ内容を 16 進数ダンプ形式の文字列として返します。
- **`o.fftt`**: 画面上の`<textarea>`に文字列を表示します。

#### 3. デバッグ表示制御関数

デバッグ情報を非同期的にテキストエリアに表示するための仕組みです。

- **`o.ff[811]`**: デバッグ情報を内部バッファ (`o.ff[1977]`以降) にセットします。
- **`o.ff[812]`**: 内部バッファにセットされた情報を`<textarea>`に表示し、バッファをクリアします。メインループの最後に呼ばれ、UI の更新を効率化しています。

#### 4. エミュレータ起動・UI イベントハンドラ

ユーザーの操作を起点とする処理群です。

- **`o.ff[999]`**: **エミュレータ起動トリガー**。画面のクリック/タッチで発火し、PPU(`o.ff[1101]`)と APU(`o.ff[1200]`)を初期化後、メインループ(`o.ff[1000]`)を開始します。
- **`o.ff[1999]`**: UI ボタンの共通イベントハンドラ。クリックされたボタンに応じて`o.ff[2000]`以降の各処理を呼び出します。
- **`o.ff[2000]`〜`o.ff[2018]`**: 各 UI ボタン（Reset, Open URL, Save, Load, FPS 変更, デバッグ表示など）に対応する個別の処理です。

#### 5. 関数テーブルの初期化

`o.ff`（関数テーブル）の一部をデフォルトの空関数で初期化します。これにより、未実装の命令や I/O ハンドラが呼び出されてもエミュレータがクラッシュするのを防ぎます。

#### 6. メモリバス (Read/Write)

メモリへのアクセスを抽象化する中心的な関数です。

- **`o.ff[800]`**: **メモリ読み込み (Read Bus)**。アドレスに応じて、ROM、RAM、VRAM、MBC（メモリバンクコントローラ）が管理する拡張メモリなど、適切な領域からデータを読み出します。
- **`o.ff[801]`**: **メモリ書き込み (Write Bus)**。アドレスに応じて適切な領域にデータを書き込みます。MBC の制御や、I/O レジスタへの書き込み時に特殊な処理（I/O ハンドラの呼び出し）をトリガーする重要な役割も担います。

#### 7. セーブ/ロード処理

- **`o.ff[820]`**: 現在の RAM の状態を`<canvas>`にピクセルデータとして描き出し、その Base64 文字列表現を`localStorage`に保存することで、セーブ機能を実現します。
- **`o.ff[821]`, `o.ff[822]`**: `localStorage`やテキストエリアから Base64 文字列を読み込み、`Image`オブジェクトを経由してピクセルデータを復元し、RAM に書き戻すことでロード機能を実現します。

#### 8. I/O レジスタハンドラ (`o.ff[0x200]`台)

`0xFF00`番台の I/O レジスタへの書き込み時に、メモリバス(`o.ff[801]`)から呼び出される関数群です。各ハードウェアの動作を制御します。

- **`o.ff[0x00 | (1 << 9)]` (FF00 - P1/JOYP)**: ジョイパッドの入力状態を制御します。書き込まれた値に応じて、方向キーとボタンキーのどちらを読み取るかを切り替えます。
- **`o.ff[0x02 | (1 << 9)]` (FF02 - SC)**: シリアル通信の制御レジスタ。2P 対戦機能に関連しているようです。
- **`o.ff[0x04 | (1 << 9)]` (FF04 - DIV)**: ディバイダレジスタ。このレジスタに書き込むと常に 0 にリセットされます。
- **`o.ff[0x07 | (1 << 9)]` (FF07 - TAC)**: タイマーコントロール。タイマーの有効/無効や、クロック周波数を設定します。
- **`o.ff[0x10-0x3F | (1 << 9)]`**: APU（Audio Processing Unit）関連のレジスタ。各サウンドチャンネルの周波数、音量、エンベロープ、波形などを設定します。
- **`o.ff[0x46 | (1 << 9)]` (FF46 - DMA)**: OAM（Object Attribute Memory）への DMA（Direct Memory Access）転送を開始します。
- **`o.ff[0x50 | (1 << 9)]` (FF50 - Boot ROM Disable)**: ブートストラップ ROM を無効化し、カートリッジ ROM のマッピングを有効にします。

#### 9. PPU (描画) 関連 (`o.ff[1101]` ~)

- **`o.ff[1101]`**: PPU 関連のオブジェクト(`o.v`)を初期化します。
- **`o.ff[1102]`**: 1 ライン分のスキャンラインを描画します。背景、ウィンドウ、スプライトの描画処理が含まれます。
- **`o.ff[1103]`**: VRAM 上のタイルデータを、描画しやすい形式にデコードして`o.v.d`にキャッシュします。
- **`o.ff[1104]`**: 1 フレーム分の描画が完了した`canvas`を画面に転送します。

#### 10. APU (音声) 関連 (`o.ff[1200]` ~)

- **`o.ff[1200]`**: Web Audio API を用いて APU 関連のオブジェクト(`o.s`)を初期化します。
- **`o.ff[1201]`**: 各サウンドチャンネルの周波数を設定します。
- **`o.ff[1202]`**: チャンネル 1 のスイープ処理を実行します。

#### 11. CPU 命令セット (`o.ff[0x00]` ~ `o.ff[0x1FF]`)

CPU の各命令に対応する関数群です。以下に代表的なグループを示します。

- **ロード命令 (LD)**: レジスタやメモリ間でデータを転送します。
- **演算命令 (ADD, SUB, AND, OR, XOR, CP, INC, DEC)**: 算術論理演算を行います。
- **回転・シフト命令 (RLCA, RRCA, RLA, RRA, etc.)**: レジスタの値をビット回転・シフトします。
- **ビット操作命令 (BIT, SET, RES)**: 特定のビットをテスト、セット、リセットします。
- **ジャンプ・コール命令 (JP, JR, CALL, RET)**: プログラムカウンタを変更し、処理の流れを制御します。
- **スタック操作命令 (PUSH, POP)**: スタックにデータをプッシュ、ポップします。

#### 12. CPU 命令: 演算命令群

A レジスタ（アキュムレータ）と他のレジスタやメモリ上の値との間で算術論理演算を行います。演算結果に応じてフラグレジスタ(F)が更新されます。

- **ADD (加算)**: `o.ff[0x80]` ~ `o.ff[0x87]`, `o.ff[0x86]`, `o.ff[0xc6]`
  - A レジスタに、指定したレジスタ・メモリ・即値の値を加算します。
  - `ADC` (`o.ff[0x88]` ~) は、キャリーフラグ(C)を含めて加算します。
- **SUB (減算)**: `o.ff[0x90]` ~ `o.ff[0x97]`, `o.ff[0x96]`, `o.ff[0xd6]`
  - A レジスタから、指定した値を減算します。
  - `SBC` (`o.ff[0x98]` ~) は、キャリーフラグ(C)を含めて減算します。
- **AND, OR, XOR (論理演算)**: `o.ff[0xa0]` ~, `o.ff[0xb0]` ~, `o.ff[0xa8]` ~
  - A レジスタとの間で、それぞれ論理積、論理和、排他的論理和を計算します。
- **CP (比較)**: `o.ff[0xb8]` ~ `o.ff[0xbf]`, `o.ff[0xbe]`, `o.ff[0xfe]`
  - A レジスタの値と指定した値を比較（内部的に減算）し、結果をフラグに反映させます。A レジスタの値は変化しません。
- **INC (インクリメント)**: `o.ff[0x04]` ~, `o.ff[0x03]` ~
  - 8bit レジスタまたは 16bit レジスタペアの値を 1 増やします。
- **DEC (デクリメント)**: `o.ff[0x05]` ~, `o.ff[0x0b]` ~
  - 8bit レジスタまたは 16bit レジスタペアの値を 1 減らします。

#### 13. CPU 命令: 回転・シフト命令群

レジスタやメモリの値をビット単位で回転・シフトさせます。フラグ(F)レジスタ、特にキャリーフラグ(C)が重要な役割を果たします。

- **RLCA, RLA**: `o.ff[0x07]`, `o.ff[0x17]`
  - A レジスタを左に回転させます。`RLA`はキャリーフラグを介して回転します。
- **RRCA, RRA**: `o.ff[0x0f]`, `o.ff[0x1f]`
  - A レジスタを右に回転させます。`RRA`はキャリーフラグを介して回転します。
- **CB プレフィックス命令**: `o.ff[0xcb]`に続く命令群 (`o.ff[0x100]`台)
  - **RLC, RL**: `o.ff[0x100]` ~
    - 指定したレジスタを左に回転させます。`RL`はキャリーフラグを介して回転します。
  - **RRC, RR**: `o.ff[0x108]` ~
    - 指定したレジスタを右に回転させます。`RR`はキャリーフラグを介して回転します。
  - **SLA, SRA, SRL**: `o.ff[0x120]` ~
    - 指定したレジスタを左または右にシフトします。`SRA`は算術シフト（符号ビットを維持）、`SRL`は論理シフト（0 で埋める）です。
  - **SWAP**: `o.ff[0x130]` ~
    - レジスタの上位 4 ビットと下位 4 ビットを入れ替えます。

#### 14. CPU 命令: ビット操作命令群

`0xCB`プレフィックスに続く命令で、特定のビットを操作します。

- **BIT**: `o.ff[0x140]` ~ `o.ff[0x17f]`
  - 指定したレジスタの特定のビットが 0 かどうかをテストし、結果をゼロフラグ(Z)にセットします。
- **RES**: `o.ff[0x180]` ~ `o.ff[0x1bf]`
  - 指定したレジスタの特定のビットを 0 にリセットします。
- **SET**: `o.ff[0x1c0]` ~ `o.ff[0x1ff]`
  - 指定したレジスタの特定のビットを 1 にセットします。

#### 15. CPU 命令: ジャンプ・コール命令群

プログラムの実行フローを制御します。

- **JP (ジャンプ)**: `o.ff[0xc3]`, `o.ff[0xc2]`, `o.ff[0xe9]` など
  - 指定したアドレスにプログラムカウンタ(PC)を無条件または条件付きで変更します。
- **JR (相対ジャンプ)**: `o.ff[0x18]`, `o.ff[0x20]` など
  - 現在のプログラムカウンタ(PC)からの相対位置にジャンプします。
- **CALL (サブルーチンコール)**: `o.ff[0xcd]`, `o.ff[0xc4]` など
  - 戻りアドレスをスタックにプッシュした後、指定したアドレスにジャンプします。
- **RET (リターン)**: `o.ff[0xc9]`, `o.ff[0xc0]` など
  - スタックから戻りアドレスをポップしてプログラムカウンタ(PC)にロードし、サブルーチンから復帰します。
- **RST (リスタート)**: `o.ff[0xc7]` ~ `o.ff[0xff]`
  - `CALL`命令の一種で、`0x0000`番地台の特定のアドレスにジャンプします。割り込み処理などで使用されます。

#### 16. CPU 命令: スタック操作命令群

スタックポインタ(SP)を操作して、スタックにデータを保存したり取り出したりします。

- **PUSH**: `o.ff[0xc5]`, `o.ff[0xd5]`, `o.ff[0xe5]`, `o.ff[0xf5]`
  - 指定した 16bit レジスタペア（AF, BC, DE, HL）の値をスタックにプッシュします。
- **POP**: `o.ff[0xc1]`, `o.ff[0xd1]`, `o.ff[0xe1]`, `o.ff[0xf1]`
  - スタックから値を取り出し、指定した 16bit レジスタペアにロードします。

#### 17. メインループ (`o.ff[1000]`) の詳細

`o.ff[1000]` は、エミュレータ全体の動作を司る心臓部です。`setTimeout` によって定期的に呼び出され、1 フレーム（約 1/60 秒）分の処理を実行します。

以下は、ループ 1 回あたりの主要な処理ステップです。

1.  **タイミング調整**:

    - `setTimeout` の呼び出し間隔を調整し、エミュレーション速度が約 60FPS になるように維持します。
    - 1 フレームあたりに実行すべき CPU サイクル数（`r[19]`）を計算します。

2.  **CPU サイクル実行ループ**:

    - 1 フレーム分のサイクル数に達するまで、以下の処理を高速で繰り返します。

3.  **割り込みチェック**:

    - `IE`レジスタ (`m[0xffff]`) と `IF`レジスタ (`m[0xff0f]`) を確認し、発生している割り込み要求をチェックします。
    - 実行すべき割り込みがあれば、現在のプログラムカウンタ(PC)をスタックに退避させ、対応する割り込みベクタ（`0x40`, `0x48`など）にジャンプします。
    - この処理のために、CPU は 6 サイクルを消費します。

4.  **命令のフェッチと実行**:

    - 割り込みが発生しなかった場合、プログラムカウンタ(PC)が指すアドレスから命令コード（オペコード）を 1 バイト読み込みます（フェッチ）。
    - 読み込んだオペコードに対応する関数を `o.ff` テーブルから探し出し、実行します（デコード＆エキュート）。
    - 実行した命令が消費したサイクル数（通常 1〜6 サイクル）を取得します。

5.  **各種ハードウェアの更新**:

    - 命令の実行によって消費されたサイクル数ぶん、各種カウンタを進めます。
    - **タイマー更新**: `DIV`レジスタ(`m[0xff04]`)や`TIMA`レジスタ(`m[0xff05]`)を更新し、指定されたクロックでタイマー割り込みを要求します。
    - **PPU 更新**: PPU の内部クロック(`r[100]`)を進め、現在のスキャンライン(`m[0xff44]`)の位置に応じて以下の処理を行います。
      - **Mode 2 (OAM スキャン)**: スプライト情報を OAM から読み取ります。
      - **Mode 3 (描画)**: 1 ライン分のピクセルデータを VRAM から読み取り、フレームバッファに描画します(`o.ff[1102]`)。
      - **Mode 0 (HBlank)**: 水平ブランク期間。
      - **Mode 1 (VBlank)**: 垂直ブランク期間。1 フレームの描画が完了し、画面を更新します(`o.ff[1104]`)。VBlank 割り込みを要求します。
    - **APU 更新**: サウンド関連のレジスタを元に、各チャンネルのエンベロープやスイープ処理などを実行します。

6.  **次のフレームへ**:
    - 1 フレーム分のサイクルをすべて消費したら、`while`ループを抜け、次の`setTimeout`の呼び出しを待ちます。
    - デバッグ表示が有効な場合は、このタイミングでレジスタ情報などを画面に表示します。
