# GBRE Web技術詳細解説

このドキュメントは、GBRE エミュレータのコアである `app.js` が、Web技術（HTML/JavaScript/CSS）の観点からどのように構築され、動作しているかを詳細に解説します。
`architecture_deep_dive.md` が「エミュレータとしてのロジック」に焦点を当てているのに対し、このドキュメントは「Webページとしての挙動」に焦点を当てます。

## 1. 全体的なJavaScript設計思想

このコードは、現代のJavaScriptフレームワークとは一線を画す、古典的かつ自己完結的なスタイルで書かれています。

### グローバルオブジェクト `o`

- **役割**: このアプリケーションのすべての状態（メモリ、レジスタ）と機能（関数）は、グローバルオブジェクト `o` に集約されています。
- **目的**: これは一種の **名前空間 (Namespace)** パターンです。グローバルスコープに多数の変数や関数を定義するのを避け、`o` という唯一のオブジェクトにまとめることで、他のライブラリとの名前衝突のリスクを低減しています。

### 関数テーブル `o.ff`

- **役割**: `o.ff` は、CPUの命令コードや特定のIDをインデックスとする巨大な関数の配列です。これは「ディスパッチテーブル」や「ジャンプテーブル」と呼ばれる設計パターンです。
- **目的**: `switch` 文や多数の `if-else` 文で処理を分岐させる代わりに、配列のインデックスを使って直接対応する関数を呼び出します。これにより、分岐処理の記述が簡潔になり、ケースによってはパフォーマンスが向上することもあります。
  - 例: `0x00` (NOP命令) が実行されるとき、`o.ff0x00` が呼び出されます。
  - 例: I/Oレジスタ `0xFF04` への書き込みは `o.ff0x04 | (1 << 9)` が呼び出されます。

## 2. DOM操作とイベントハンドリング

このアプリケーションは、jQueryやReactのようなDOM操作ライブラリを使わず、ブラウザが標準で提供するAPI（Vanilla JS）のみでUIを構築・操作しています。

### UIの動的生成 (`onload` イベント)

- **処理の流れ**: HTMLが読み込まれた直後、`onload` イベントに登録された関数が実行されます。
- **内容**:
  1. `document.createElement` を使って、`<canvas>`, `<button>`, `<textarea>` などのHTML要素をプログラムで生成します。
  2. `element.className` でCSSクラスを割り当て、スタイルを適用します。
  3. `document.body.appendChild` を使って、生成した要素をHTMLの `<body>` タグ内に配置します。
  - このアプローチにより、HTMLファイルには `<script>` タグ以外ほとんど記述する必要がなくなり、JavaScript側でUI構造を完結させています。

### イベントリスナーの登録

- **方法**: `element.addEventListener('click', ...)` のような現代的な方法ではなく、`element.onclick = ...` や `document.onkeydown = ...` のように、要素のプロパティに直接イベントハンドラ関数を代入する古典的な方法が使われています。
- **主要なイベントハンドラ**:
  - **`o.ff[999]` (エミュレータ起動)**: ゲーム画面用Canvasの `onclick` と `ontouchstart` に設定されています。音声再生(`AudioContext`)の開始にはユーザーの操作が必須であるため、このタイミングで初期化処理とメインループを開始します。
  - **`o.ff[1999]` (UIボタン共通ハンドラ)**: 「Reset」や「Save」などの全ボタンの `onclick` に設定されています。各ボタン要素には `button.i` というカスタムプロパティにインデックス番号が保持されており、ハンドラはこのインデックスを元に `o.ff[2000 + index]` のように呼び出す処理を分岐させています。
  - **`o.ff[997]` (キーボード入力)**: `document.onkeydown` と `onkeyup` に設定されています。押されたキーの `keyCode` を元に、どのボタンが押された/離されたかを判定し、エミュレータ内部のジョイパッド状態 (`o.r[111]`) のビットを操作します。
  - **`o.ff[998]` (タッチ入力)**: 十字キーやABボタン用のCanvasに設定されています。`e.targetTouches` からタッチ座標を取得し、Canvas上のどのエリアがタッチされたかを計算して、対応するジョイパッド状態のビットを操作します。`e.preventDefault()` を呼び出し、タッチ操作による画面のスクロールやズームを防いでいます。

## 3. 描画処理 (Canvas 2D API)

ゲーム画面の描画には `<canvas>` 要素の2Dレンダリングコンテキストが使われています。パフォーマンスを意識した工夫が見られます。

### 内部フレームバッファと `putImageData`

- **内部バッファ**: `o.ff[1101]` (PPU初期化処理) で `v.cc.createImageData()` を使って `v.ii` というImageDataオブジェクトが作成されます。この `v.ii.data` (Uint8ClampedArray) のバッファを `v.m` (Uint32Array) として参照し、内部的なフレームバッファとして利用します。
- **描画ステップ**:
  1. **`o.ff[1102]` (スキャンライン描画)**: PPUの動作をエミュレートし、1ライン分のピクセル色情報を計算して、直接画面に描画するのではなく、内部フレームバッファ `v.m` に32bit整数として高速に書き込みます。
  2. **`o.ff[1104]` (画面更新)**: 1フレーム（144ライン）分の描画が完了したタイミングで、完成した内部フレームバッファ `v.ii` を `v.cc.putImageData()` を使って一気にCanvasに転送します。
- **目的**: この手法は「ダブルバッファリング」に似た考え方です。描画の途中経過をユーザーに見せることなく、完成したフレームのみを表示するため、画面のちらつき（フリッカリング）を防ぐことができます。

### `toDataURL` と `drawImage` を利用したセーブ/ロード

- **セーブ (`o.ff[820]`)**:
  1. ゲームのRAMデータを、非表示の `<canvas>` (`.svsv`) にピクセルデータとして `putImageData` で描き出します。
  2. `canvas.toDataURL()` を呼び出し、Canvasの内容をPNG形式のBase64文字列に変換します。
  3. この文字列を `localStorage.setItem()` でブラウザの永続ストレージに保存します。
  - RAMのバイナリデータを直接保存するのではなく、画像として保存するのは、データの圧縮（PNG形式による）と、テキストベースでの取り扱い（Base64）を容易にするための独創的なテクニックです。

- **ロード (`o.ff[822]`)**:
  1. `localStorage.getItem()` でBase64文字列を読み出します。
  2. `new Image()` で画像オブジェクトを作成し、`.src` にBase64文字列を設定して画像をデコードします。
  3. 画像の `onload` イベントで、非表示Canvasに `drawImage()` を使って画像をレンダリングします。
  4. `getImageData()` でCanvasからピクセルデータを読み出し、その値をRAMに書き戻すことでゲームの状態を復元します。

## 4. 非同期処理とメインループ

### `setTimeout` によるメインループ

- **役割**: `o.ff[1000]` (メインループ) は、関数の最後で `setTimeout(ff[1000], ...)` を呼び出すことで、自身を再帰的に、しかし非同期に呼び出します。
- **目的**:
  - **ブラウザの応答性維持**: もし `while(true)` のような同期的な無限ループを組んでしまうと、ブラウザのUIスレッドがブロックされ、ページ全体がフリーズしてしまいます。`setTimeout` を使うことで、ループの合間にブラウザが他の処理（UIの再描画やユーザー入力の受付など）を行う隙を与えています。
  - **FPS制御**: `setTimeout` の第2引数（遅延時間）を動的に調整することで、エミュレーションの速度を目標のフレームレート（約60FPS）に近づけるように制御しています。

### デバッグ表示の非同期更新

- **役割**: デバッグ情報を表示する際、`o.ff[811]` で表示したい文字列を内部バッファ (`o.ff[1977]`以降) にセットするだけに留めます。
- **目的**: 実際のDOM更新（`<textarea>`への値のセット）は、メインループの最後で呼ばれる `o.ff[812]` がまとめて行います。ループの度に高頻度でDOMを更新するとパフォーマンスが著しく低下するため、更新を1フレームに1回に間引くことで、負荷を軽減しています。

## 5. その他Web関連技術

### Web Audio API

- **役割**: `o.ff[1200]` 以降の関数群で、ゲームボーイのAPU（音声処理装置）をエミュレートしています。
- **実装**: `AudioContext` を生成し、`createBufferSource` で波形データを生成、`createGainNode` で音量を制御し、`playbackRate` を変更することで音の高さを制御しています。これにより、BGMや効果音をリアルタイムに生成・再生しています。

### XMLHttpRequest

- **役割**: `o.ff[844]` で、URLからROMファイルを非同期にダウンロードするために使用されています。
- **実装**: `responseType = 'arraybuffer'` を指定することで、レスポンスをバイナリデータ (`ArrayBuffer`) として直接受け取り、エミュレータのメモリ (`o.m`) に効率的に書き込んでいます。

### File API

- **役割**: `o.ff[846]` で、ユーザーがローカルのROMファイルを選択した際の読み込み処理を担っています。
- **実装**: `<input type="file">` の `onchange` イベントで発火し、`FileReader` を使ってファイルを `ArrayBuffer` として非同期に読み込んでいます。
